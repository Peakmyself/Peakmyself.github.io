<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>struct</title>
    <url>/2020/02/24/struct/</url>
    <content><![CDATA[<h1 id="结构和其他数据形式"><a href="#结构和其他数据形式" class="headerlink" title="结构和其他数据形式"></a>结构和其他数据形式</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构的基本操作"><a href="#结构的基本操作" class="headerlink" title="结构的基本操作"></a>结构的基本操作</h3><h4 id="结构的声明"><a href="#结构的声明" class="headerlink" title="结构的声明"></a>结构的声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> title [MAXTITL];</span><br><span class="line"><span class="keyword">char</span> author [MAXTITL];</span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span><span class="comment">//如果稍后使用这个结构，可以用这个语句进行声明，编译器使用book模板为library分配空间：一个内含MAXTITL个元素的char数组、一个内含 MAXTITL个元素的char数组和一个float类型的变量。</span></span><br></pre></td></tr></table></figure>

<p>struct在结构变量声明中相当于int或者float等类型。声明可以放在函数定义的内部，仅限函数内部使用，但我们通常都放在函数外部。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span> </span><br><span class="line"><span class="keyword">char</span> title[MAXTITL]; </span><br><span class="line"><span class="keyword">char</span> author[AXAUTL]; </span><br><span class="line"><span class="keyword">float</span> value;</span><br><span class="line">&#125; library;   <span class="comment">//这是上面struct book library;声明的简化，若将声明结构和定义结构变量的过程一起完成，可以省略结构名也就是book，</span></span><br></pre></td></tr></table></figure>

<h4 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h4><p>将所有变量全部初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> =&#123;</span></span><br><span class="line"><span class="string">"苏东坡传"</span>,</span><br><span class="line"><span class="string">"林语堂"</span>,</span><br><span class="line"><span class="number">28</span> &#125;;<span class="comment">//类似于数组的初始化</span></span><br></pre></td></tr></table></figure>

<p>仅初始化一个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span> .value = <span class="number">10.99</span>&#125;;<span class="comment">//只初始化一个book结构中的value成员</span></span><br></pre></td></tr></table></figure>

<p>新的赋值会替代旧的赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gift</span>= &#123;</span>.value = <span class="number">18.90</span>, </span><br><span class="line">                   .author = <span class="string">"Philionna Pestle"</span>,</span><br><span class="line">                   <span class="number">0.25</span>&#125;;</span><br><span class="line"><span class="comment">//赋给value的值是0.25，因为它在结构声明中紧跟在author成员之后。新值0.25取代了之前的18.9。</span></span><br></pre></td></tr></table></figure>



<h4 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h4><p>数组可以通过下标进行单独访问某个元素，那么如何访问结构体成员呢？结构成员使用点（.）运算符访问结构的成员，例如：library.title 即访问library的title部分，本质上，.title、.author和.value的作用相当于book结构的下标。虽然library是一个结构，但是library.value是一个float类型的变量，例如，scanf(“%f”,…)需要一 个 float 类型变量的地址，而&amp;library.float正好符合要求。.比&amp;的优先级高， 因此这个表达式和&amp;(library.float)一样。</p>
<h3 id="结构与数组"><a href="#结构与数组" class="headerlink" title="结构与数组"></a>结构与数组</h3><h4 id="声明结构数组"><a href="#声明结构数组" class="headerlink" title="声明结构数组"></a>声明结构数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[20];</span> <span class="comment">//把library声明为一个内含20个元素的数组。数组的每个元素都是一个book类型的数组，相当于library[0],library[1],library[2],而每个library[]是结构变量名，其中包含title、author和value这些变量。</span></span><br></pre></td></tr></table></figure>

<img src="C:\Users\One-day\AppData\Roaming\Typora\typora-user-images\image-20200224090503660.png" alt="image-20200224090503660" style="zoom: 80%;" />

<h4 id="访问结构数组的成员"><a href="#访问结构数组的成员" class="headerlink" title="访问结构数组的成员"></a>访问结构数组的成员</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">library[<span class="number">0</span>].value;<span class="comment">/* 访问第1个数组元素的value */</span></span><br><span class="line">library[<span class="number">4</span>].title;<span class="comment">/* 访问第5个数组元素的title */</span></span><br><span class="line">library[<span class="number">2</span>].title[<span class="number">4</span>] <span class="comment">//这是library数组第3个结构变量（library[2]部分）中书名的第5个字符</span></span><br><span class="line">（title[<span class="number">4</span>]部分）。</span><br></pre></td></tr></table></figure>

<p>该例指出，<strong>点运算符右侧的下标作用于各个成员，点运算符左侧的下标作用与结构数组</strong>。访问形式应该是结构数组.成员</p>
<p><strong>以下是书中的总结：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">library						<span class="comment">// 一个book 结构的数组</span></span><br><span class="line">library[<span class="number">2</span>] 					<span class="comment">// 一个数组元素，该元素是book结构</span></span><br><span class="line">library[<span class="number">2</span>].title			<span class="comment">// 一个char数组（library[2]的title成员）</span></span><br><span class="line">library[<span class="number">2</span>].title[<span class="number">4</span>]    		<span class="comment">// 数组中library[2]元素的title 成员的一个字符</span></span><br></pre></td></tr></table></figure>

<h3 id="结构与指针"><a href="#结构与指针" class="headerlink" title="结构与指针"></a>结构与指针</h3><h4 id="声明和初始化结构指针"><a href="#声明和初始化结构指针" class="headerlink" title="声明和初始化结构指针"></a>声明和初始化结构指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut book *p; <span class="comment">//声明方式和其他指针类型一样</span></span><br><span class="line">p=&amp;library;		<span class="comment">//和数组不同的是，结构名不是结构的地址，所以要加上&amp;运算符</span></span><br><span class="line">p=&amp;library[<span class="number">0</span>];		<span class="comment">//如果library是结构数组</span></span><br></pre></td></tr></table></figure>

<h4 id="用指针访问成员-gt"><a href="#用指针访问成员-gt" class="headerlink" title="用指针访问成员 -&gt;"></a>用指针访问成员 -&gt;</h4><p>第一种方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果p=&amp;library, p-&gt;value 就是 library.value，p是一个指针，但是p-&gt;value是该指针所指向结构的一个成员。所以 p-&gt;value是一个<span class="keyword">float</span>类型的变量</span><br></pre></td></tr></table></figure>

<p>第二种方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如果p=&amp;library[<span class="number">0</span>],那么p=library[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>可以做如下替换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">library[<span class="number">0</span>].value=(p).value;需要括号，.比*运算符优先级高</span><br></pre></td></tr></table></figure>

<p>如果p是book类型结构library的指针，<strong>下面的关系恒成立</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library.value &#x3D; (*p).value &#x3D; p-&gt;value &#x2F;&#x2F;假设p&#x3D;&amp;library</span><br></pre></td></tr></table></figure>

<h3 id="函数与结构体"><a href="#函数与结构体" class="headerlink" title="函数与结构体"></a>函数与结构体</h3><h4 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a>向函数传递结构的信息</h4><p>向函数传递结构体本身还是指向结构体的指针，也可以把结构体的成员作为参数</p>
<h3 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h3><p>直接使用library.value这种方式即可访问</p>
<h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   bank[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankfund;</span><br><span class="line">    <span class="keyword">char</span>   save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>;  <span class="comment">/* argument is a pointer */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">        <span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line">        <span class="number">4032.27</span>,</span><br><span class="line">        <span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line">        <span class="number">8543.94</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(&amp;stan));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(money-&gt;bankfund + money-&gt;savefund);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum()函数使用指向funds结构的指针（money）作为它的参数。把地址&amp;stan传递给该函数，使得指针money指向结构stan。然后通过-&gt;运算符获取 stan.bankfund和stan.savefund的值。也可以使用(*money).bankfund进行取值</span></span><br></pre></td></tr></table></figure>

<h4 id="传递结构体"><a href="#传递结构体" class="headerlink" title="传递结构体"></a>传递结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   bank[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankfund;</span><br><span class="line">    <span class="keyword">char</span>   save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span>;  <span class="comment">/* argument is a structure */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">        <span class="string">"Garlic-Melon Bank"</span>,</span><br><span class="line">        <span class="number">4032.27</span>,</span><br><span class="line">        <span class="string">"Lucky's Savings and Loan"</span>,</span><br><span class="line">        <span class="number">8543.94</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f.\n"</span>, sum(stan));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(moolah.bankfund + moolah.savefund);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和上面的进行对比，调用sum()时，编译器根据funds模板创建 了一个名为moolah的自动结构变量。然后，该结构的各成员被初始化为 stan 结构变量相应成员的值的副本。因此，程序使用原来结构的副本进行计算，因为这里的moolah是一个结构体，所以使用点运算符而不使用-&gt;运算符。</span></span><br></pre></td></tr></table></figure>

<h4 id="其他结构特性"><a href="#其他结构特性" class="headerlink" title="其他结构特性"></a>其他结构特性</h4><p>可以把一个结构赋值给另外一个结构,把每个成员的值都赋给另外一个成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o_data&#x3D;n_data;</span><br></pre></td></tr></table></figure>

<h4 id="结构中的字符数组和字符指针"><a href="#结构中的字符数组和字符指针" class="headerlink" title="结构中的字符数组和字符指针"></a>结构中的字符数组和字符指针</h4><p>结构声明中是否可以使用指针代替字符数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> * first; </span><br><span class="line"><span class="keyword">char</span> * last; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct pnames结构不用为字符串 分配任何存储空间。它使用的是储存在别处的字符串（如，字符串常量或数 组中的字符串）。如果其他地方没有已经分配好的字符串，结果可能会出现很大的问题。如下的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney:"</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last);<span class="comment">/* 这里有一个潜在的危险 */</span></span><br><span class="line"><span class="comment">//*由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方，我们并不知道attorney,last的值存储在了什么地方。</span></span><br></pre></td></tr></table></figure>

<h4 id="结构、指针和malloc"><a href="#结构、指针和malloc" class="headerlink" title="结构、指针和malloc()"></a>结构、指针和malloc()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// names3.c -- use pointers and malloc()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;   // for strcpy(), strlen()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;   // for malloc(), free()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEN 81</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * fname;  <span class="comment">// using pointers</span></span><br><span class="line">    <span class="keyword">char</span> * lname;</span><br><span class="line">    <span class="keyword">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinfo</span><span class="params">(struct namect *)</span></span>;        <span class="comment">// allocates memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeinfo</span><span class="params">(struct namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">(<span class="keyword">const</span> struct namect *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(struct namect *)</span></span>;        <span class="comment">// free memory when done</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">namect</span> <span class="title">person</span>;</span></span><br><span class="line">    </span><br><span class="line">    getinfo(&amp;person);</span><br><span class="line">    makeinfo(&amp;person);</span><br><span class="line">    showinfo(&amp;person);</span><br><span class="line">    cleanup(&amp;person);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinfo</span> <span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[SLEN];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter your first name.\n"</span>);</span><br><span class="line">    s_gets(temp, SLEN);</span><br><span class="line">    <span class="comment">// allocate memory to hold name</span></span><br><span class="line">    pst-&gt;fname = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// copy name to allocated memory</span></span><br><span class="line">    <span class="built_in">strcpy</span>(pst-&gt;fname, temp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter your last name.\n"</span>);</span><br><span class="line">    s_gets(temp, SLEN);</span><br><span class="line">    pst-&gt;lname = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(pst-&gt;lname, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeinfo</span> <span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pst-&gt;letters = <span class="built_in">strlen</span>(pst-&gt;fname) +</span><br><span class="line">    <span class="built_in">strlen</span>(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showinfo</span> <span class="params">(<span class="keyword">const</span> struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s, your name contains %d letters.\n"</span>,</span><br><span class="line">           pst-&gt;fname, pst-&gt;lname, pst-&gt;letters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(struct namect * pst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(pst-&gt;fname);</span><br><span class="line">    <span class="built_in">free</span>(pst-&gt;lname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">char</span> * <span class="built_in">find</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">find</span> = <span class="built_in">strchr</span>(st, <span class="string">'\n'</span>);   <span class="comment">// look for newline</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>)                  <span class="comment">// if the address is not NULL,</span></span><br><span class="line">            *<span class="built_in">find</span> = <span class="string">'\0'</span>;          <span class="comment">// place a null character there</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;          <span class="comment">// dispose of rest of line</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line">P1055页</span><br></pre></td></tr></table></figure>





<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2>]]></content>
  </entry>
  <entry>
    <title>first article</title>
    <url>/2020/02/16/first-article/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
